export interface ConversationMessage {
  id: string
  text: string
  sender: 'user' | 'bot'
  timestamp: Date
  type: 'text' | 'recommendation' | 'action'
}

export interface ConversationExport {
  sessionId: string
  exportDate: Date
  farmingData?: any
  messages: ConversationMessage[]
  summary: {
    totalMessages: number
    topics: string[]
    keyRecommendations: string[]
    weatherAlerts: string[]
  }
  metadata: {
    language: string
    region: string
    expertiseLevel: string
    duration: string
  }
}

export interface ExportFormat {
  type: 'json' | 'pdf' | 'txt' | 'csv'
  filename: string
  content: string | Buffer
}

class ConversationExportService {
  exportToJSON(conversation: ConversationExport): ExportFormat {
    const content = JSON.stringify(conversation, null, 2)
    return {
      type: 'json',
      filename: `grainkeeper_conversation_${conversation.sessionId}_${new Date().toISOString().split('T')[0]}.json`,
      content
    }
  }

  exportToTXT(conversation: ConversationExport): ExportFormat {
    let content = `GRAINKEEPER Conversation Export\n`
    content += `Session ID: ${conversation.sessionId}\n`
    content += `Export Date: ${conversation.exportDate.toLocaleString()}\n`
    content += `Duration: ${conversation.metadata.duration}\n`
    content += `Language: ${conversation.metadata.language}\n`
    content += `Region: ${conversation.metadata.region}\n`
    content += `Expertise Level: ${conversation.metadata.expertiseLevel}\n\n`

    if (conversation.farmingData) {
      content += `FARMING PROFILE:\n`
      content += `Location: ${conversation.farmingData.location?.city}, ${conversation.farmingData.location?.province}\n`
      content += `Rice Variety: ${conversation.farmingData.crop?.variety}\n`
      content += `Growth Stage: ${conversation.farmingData.crop?.growthStage}\n`
      content += `Soil Type: ${conversation.farmingData.soil?.type}\n\n`
    }

    content += `CONVERSATION SUMMARY:\n`
    content += `Total Messages: ${conversation.summary.totalMessages}\n`
    content += `Topics Discussed: ${conversation.summary.topics.join(', ')}\n`
    content += `Key Recommendations: ${conversation.summary.keyRecommendations.length}\n`
    content += `Weather Alerts: ${conversation.summary.weatherAlerts.length}\n\n`

    content += `CONVERSATION LOG:\n`
    content += `========================================\n\n`

    conversation.messages.forEach((message, index) => {
      const time = message.timestamp.toLocaleTimeString()
      const sender = message.sender === 'user' ? 'ðŸ‘¤ You' : 'ðŸ¤– GRAINKEEPER'
      content += `[${time}] ${sender}:\n${message.text}\n\n`
    })

    content += `========================================\n`
    content += `End of Conversation\n`
    content += `Generated by GRAINKEEPER AI Farming Assistant\n`

    return {
      type: 'txt',
      filename: `grainkeeper_conversation_${conversation.sessionId}_${new Date().toISOString().split('T')[0]}.txt`,
      content
    }
  }

  exportToCSV(conversation: ConversationExport): ExportFormat {
    let content = 'Timestamp,Sender,Message Type,Message\n'
    
    conversation.messages.forEach(message => {
      const timestamp = message.timestamp.toISOString()
      const sender = message.sender === 'user' ? 'User' : 'GRAINKEEPER'
      const messageType = message.type
      const text = message.text.replace(/"/g, '""') // Escape quotes for CSV
      
      content += `"${timestamp}","${sender}","${messageType}","${text}"\n`
    })

    return {
      type: 'csv',
      filename: `grainkeeper_conversation_${conversation.sessionId}_${new Date().toISOString().split('T')[0]}.csv`,
      content
    }
  }

  generateSummary(messages: ConversationMessage[], farmingData?: any): {
    totalMessages: number
    topics: string[]
    keyRecommendations: string[]
    weatherAlerts: string[]
  } {
    const topics = new Set<string>()
    const recommendations: string[] = []
    const weatherAlerts: string[] = []

    messages.forEach(message => {
      if (message.sender === 'bot') {
        const text = message.text.toLowerCase()
        
        // Extract topics
        if (text.includes('weather') || text.includes('rain') || text.includes('temperature')) {
          topics.add('Weather')
        }
        if (text.includes('fertilizer') || text.includes('nutrient') || text.includes('soil')) {
          topics.add('Fertilizer Management')
        }
        if (text.includes('pest') || text.includes('disease') || text.includes('control')) {
          topics.add('Pest Management')
        }
        if (text.includes('irrigation') || text.includes('water') || text.includes('drainage')) {
          topics.add('Irrigation')
        }
        if (text.includes('harvest') || text.includes('yield') || text.includes('production')) {
          topics.add('Harvest & Yield')
        }
        if (text.includes('planting') || text.includes('seed') || text.includes('variety')) {
          topics.add('Planting & Varieties')
        }

        // Extract recommendations
        const recLines = text.split('\n').filter(line => 
          line.includes('â€¢') || line.includes('-') || line.includes('recommend')
        )
        recommendations.push(...recLines.slice(0, 5))

        // Extract weather alerts
        if (text.includes('alert') || text.includes('warning') || text.includes('emergency')) {
          weatherAlerts.push(message.text)
        }
      }
    })

    return {
      totalMessages: messages.length,
      topics: Array.from(topics),
      keyRecommendations: recommendations.slice(0, 10),
      weatherAlerts: weatherAlerts.slice(0, 5)
    }
  }

  createShareableLink(conversation: ConversationExport): string {
    // In a real implementation, this would save to a database and return a shareable URL
    const shareId = `share_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    return `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/share/${shareId}`
  }

  generateReport(conversation: ConversationExport): string {
    let report = `# GRAINKEEPER Farming Consultation Report\n\n`
    report += `**Session ID:** ${conversation.sessionId}\n`
    report += `**Date:** ${conversation.exportDate.toLocaleDateString()}\n`
    report += `**Duration:** ${conversation.metadata.duration}\n\n`

    if (conversation.farmingData) {
      report += `## Farming Profile\n`
      report += `- **Location:** ${conversation.farmingData.location?.city}, ${conversation.farmingData.location?.province}\n`
      report += `- **Rice Variety:** ${conversation.farmingData.crop?.variety}\n`
      report += `- **Growth Stage:** ${conversation.farmingData.crop?.growthStage}\n`
      report += `- **Soil Type:** ${conversation.farmingData.soil?.type}\n\n`
    }

    report += `## Consultation Summary\n`
    report += `- **Total Messages:** ${conversation.summary.totalMessages}\n`
    report += `- **Topics Discussed:** ${conversation.summary.topics.join(', ')}\n`
    report += `- **Key Recommendations:** ${conversation.summary.keyRecommendations.length}\n`
    report += `- **Weather Alerts:** ${conversation.summary.weatherAlerts.length}\n\n`

    if (conversation.summary.keyRecommendations.length > 0) {
      report += `## Key Recommendations\n`
      conversation.summary.keyRecommendations.forEach(rec => {
        report += `- ${rec}\n`
      })
      report += `\n`
    }

    if (conversation.summary.weatherAlerts.length > 0) {
      report += `## Weather Alerts\n`
      conversation.summary.weatherAlerts.forEach(alert => {
        report += `- ${alert}\n`
      })
      report += `\n`
    }

    report += `## Next Steps\n`
    report += `1. Review the recommendations provided\n`
    report += `2. Implement suggested practices based on your farming conditions\n`
    report += `3. Monitor weather conditions and adjust practices accordingly\n`
    report += `4. Contact local agricultural extension services for additional support\n\n`

    report += `---\n`
    report += `*Generated by GRAINKEEPER AI Farming Assistant*\n`

    return report
  }
}

export const conversationExportService = new ConversationExportService()
